<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item expanded "><a href="lesson1/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="lesson2/metrics-and-evaluation.html"><strong aria-hidden="true">2.</strong> Metrics and Evaluation</a></li><li class="chapter-item expanded "><a href="lesson3/pipelining.html"><strong aria-hidden="true">3.</strong> Pipelining</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome" id="welcome">Welcome</a></h1>
<p>This notebook contains my personal notes for CS6290: High Performance Computer
Architecture offered at the Georgia Institute of Technology. A summary of the
course follows:</p>
<p>This course covers modern computer architecture, including branch prediction,
out-of-order instruction execution, cache optimizations, multi-level caches,
memory and storage, cache coherence and consistency, and multi- and many-core
processors.</p>
<h2><a class="header" href="#course-links" id="course-links">Course links</a></h2>
<ul>
<li><a href="https://omscs.gatech.edu/cs-6290-high-performance-computer-architecture">https://omscs.gatech.edu/cs-6290-high-performance-computer-architecture</a></li>
<li><a href="https://ebookcentral-proquest-com.prx.library.gatech.edu/lib/gatech/detail.action?docID=787253">https://ebookcentral-proquest-com.prx.library.gatech.edu/lib/gatech/detail.action?docID=787253</a></li>
</ul>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h2><a class="header" href="#what-is-computer-architecture" id="what-is-computer-architecture">What is computer architecture?</a></h2>
<p>We can think of computer architecture similar to how architecture is considered
for building. Buildings are designed to be well-suited for a specific purpose.
The same can be said of computers, as we design different computers for
different purposes. Some examples are desktop computers, laptops, and
cellphones; they all have different purposes and require different computer
architectures.</p>
<p><img src="lesson1/./img/what-is-computer-architecture.png" alt="what-is-computer-architecture" /></p>
<h2><a class="header" href="#why-do-we-need-computer-architecture" id="why-do-we-need-computer-architecture">Why do we need computer architecture?</a></h2>
<ol>
<li>To improve performance based upon some specific measure. These measures
could include:</li>
</ol>
<ul>
<li>Speed</li>
<li>Battery life</li>
<li>Size</li>
<li>Weight</li>
<li>Energy efficiency, etc.</li>
</ul>
<ol start="2">
<li>To improve the abilities provided by a computer. These abilities could include:</li>
</ol>
<ul>
<li>3D graphics</li>
<li>Debugging support</li>
<li>Security, etc.</li>
</ul>
<p>The first need for computer architecture is about making computers cheaper,
faster, smaller, etc. while the second need is based around making new things
possible/providing new functionality. Computer architecture utilizes discoveries
in fabrication technology and circuit design to achieve the goals stated above.</p>
<p><img src="lesson1/./img/why-do-we-need-computer-architecture.png" alt="why-do-we-need-computer-architecture" /></p>
<h2><a class="header" href="#computer-architecture-and-technology-trends" id="computer-architecture-and-technology-trends">Computer architecture and technology trends</a></h2>
<p>Computer architecture is about building future computers. The progress in
computer manufacturing technology is fast. We shouldn't design a new computer
with current technology and parts. By the time we've designed our new computer,
it's obsolete and using old technology. We need to track technology trends in
order to predict what's available in the future, allowing us to better design a
new computer using these new technologies.</p>
<p><img src="lesson1/./img/computer-arch-tech-trends.png" alt="computer-arch-tech-trends" /></p>
<h2><a class="header" href="#moores-law" id="moores-law">Moore's law</a></h2>
<p>Moore's law provides a good starting point for predicting what future computers
will look like based upon what is currently available today. As computer
architects, we can use these predictions to guide our expectations of what
technologies will be available for use when designing future computers. Below is
a high-level summary of Moore's law:</p>
<p><img src="lesson1/./img/moores-law.png" alt="moores-law" /></p>
<h2><a class="header" href="#the-memory-wall" id="the-memory-wall">The memory wall</a></h2>
<p>Processor speed doubles almost every two years, while memory capacity also
experiences the same phenomenon. Memory latency, however, has not kept pace with
processor speed and memory capacity. This is what's called the memory wall and,
in order to mitigate these differences in speed when processors need to access
memory, we have been using caches to close that gap. Caches can be thought of as
a series of stairs for memory access speed, and cache misses are the base of the
staircase with the slowest memory access speed possible. A high-level
illustration of the memory wall trend is provided below:</p>
<p><img src="lesson1/./img/memory-wall.png" alt="memory-wall" /></p>
<h2><a class="header" href="#power-consumption" id="power-consumption">Power consumption</a></h2>
<p>There are two kinds of power that a processor consumes:</p>
<ul>
<li>Dynamic (active) power - consumed by activity in a circuit</li>
<li>Static power - consumed when powered on but idle</li>
</ul>
<h3><a class="header" href="#active-power" id="active-power">Active power</a></h3>
<p>Below is an illustrative representation of the equation for calculating active
power consumption by a processor. The representation also displays how we can
calculate the change in active power consumption when a different chip
configuration is used, and if voltage and chip frequency are changed. An
explanation of each variable in the active power equation follows:</p>
<ul>
<li>capacitance - roughly proportional to chip area / larger chips will have more
capacitance</li>
<li>voltage - quadratic relationship between voltage and power consumption</li>
<li>frequency - clock frequency (GHz) of a processor</li>
<li>alpha - activity factor (percentage of processor transistors active for any
given clock cycle)</li>
</ul>
<p><img src="lesson1/./img/active-power.png" alt="active-power" /></p>
<h3><a class="header" href="#static-power" id="static-power">Static power</a></h3>
<p>Static power is power consumed while the processor is idle. Some of this is due
to the voltage being too low to prevent transistors from leaking/wasting energy,
but it can also come from other sources as well. Below is a high-level
representation identifying the relationship between static and active power as
voltage increases or decreases in the circuit. This representation also
identifies that there is some optimal voltage settings for circuits to avoid
utilize too much power in bot the active and static states.</p>
<p><img src="lesson1/./img/static-power.png" alt="static-power" /></p>
<h2><a class="header" href="#fabrication-cost-and-yield" id="fabrication-cost-and-yield">Fabrication cost and yield</a></h2>
<p>The cost to manufacture and convert silicone wafers to useable computer chips
is pretty much static. We, primarily, have to account for chip yield when a
silicone wafer is divided into a number computer chips - some of these chips
can have defects while others work fine. Below is high-level representation of
the silicone wafer to computer chip manufacturing process, and how the yield
is derived based upon the number of defects in wafer versus the number of chips
extracted from a wafer.</p>
<p><img src="lesson1/./img/fab-yield.png" alt="fab-yield" /></p>
<p>Below is an example of how we can calculate the fabrication cost per chip
based upon chip size. Smaller chips cost less to manufacture, while larger chips
cost the most. Smaller chips, over time according to Moore's Law, will be able
to do more for less as we are able to fit smaller transistors onto the chips.
Larger chips will be able to remain the same size and cost, however, they will
be faster overall due to Moore's Law.</p>
<p><img src="lesson1/./img/fab-cost.png" alt="fab-cost" /></p>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ol>
<li><a href="lesson1/./pdf/Lesson1Notes.pdf">Lesson 1 Notes</a></li>
</ol>
<h1><a class="header" href="#metrics-and-evaluation" id="metrics-and-evaluation">Metrics and Evaluation</a></h1>
<p>This lesson covers latency and throughput, two metrics used to measure computer
performance.</p>
<h2><a class="header" href="#performance" id="performance">Performance</a></h2>
<ul>
<li><strong>Latency</strong> - the total time it takes for an operation to complete, from start
to finish.</li>
<li><strong>Throughput</strong> - <em>not the inverse of latency</em>; because operations can take
place concurrently within a pipeline, this can be thought of as the number of
operations completed per unit measure of time.</li>
</ul>
<p>Below is a high-level representation of this concept.</p>
<p><img src="lesson2/./img/latency-throughput.png" alt="latency-throughput" /></p>
<h2><a class="header" href="#comparing-performance" id="comparing-performance">Comparing performance</a></h2>
<p>Knowing how to measure performance, we can now compare the performance of two
systems using our metrics. We want to be able to make a definitive statement
about the <strong>speedup</strong> of a system in comparison to another system, basically
stating that system <strong>x</strong> is faster than system <strong>y</strong>. We can compute this with
both <strong>latency</strong> and <strong>throughput</strong>, however, our equations are slightly
different. Below is an image showing us the equations for computing <strong>speedup</strong>
using our two metrics.</p>
<p><img src="lesson2/./img/comparing-performance.png" alt="comparing-performance" /></p>
<h2><a class="header" href="#speedup" id="speedup">Speedup</a></h2>
<p>A <strong>speedup</strong> value larger than 1 means we have improved performance. With
improved performance, we achieve higher throughput and shorter execution time. A
speedup less than 1 means that we have worse performance. When computing
speedup, we need to remember that performance is directly proportional to
throughput and performance has an inverse relationship with latency.</p>
<p><img src="lesson2/./img/speedup.png" alt="speedup" /></p>
<h2><a class="header" href="#measuring-performance" id="measuring-performance">Measuring performance</a></h2>
<p>What workload do we use to measure performance of different systems? We can't
use an actual user workload because:</p>
<ul>
<li>Many different users use computers in many different ways with many different
programs.</li>
<li>One workload will not be representative of all users.</li>
<li>How are we supposed to acquire the workload data?</li>
</ul>
<p>In order to solve this issue, we use <strong>benchmark</strong> workloads.</p>
<h2><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h2>
<p>Benchmarks are programs and input data that users and organizations have agreed
upon for use in performance measurements. Usually, we don't have just one
benchmark program but a <strong>benchmark suite</strong> consisting of multiple programs and
input data. Each program within a benchmark suite is representative of a type
of application.</p>
<h2><a class="header" href="#types-of-benchmarks" id="types-of-benchmarks">Types of benchmarks</a></h2>
<p>So what types of benchmarks are commonly used to measure performance? We have:</p>
<ul>
<li>
<p><strong>Real applications</strong></p>
<ul>
<li>Most representative of real workloads.</li>
<li>Also the most difficult to setup on new machines. Our testing environment
likely doesn't have an operating system, hardware, graphics processors, etc.</li>
</ul>
</li>
<li>
<p><strong>Kernels</strong></p>
<ul>
<li>The most time consuming portions of an application, usually a loop of some
sort. We've isolated these processing intensive sections of code to test our
machine. <em>Usually good for testing prototypes.</em></li>
</ul>
</li>
<li>
<p><strong>Synthetic benchmarks</strong></p>
<ul>
<li>Behave similar to kernels but are simpler to compile. We utilize these
benchmarks when testing early prototypes of a machine. <em>Usually good for design</em>
<em>studies.</em></li>
</ul>
</li>
<li>
<p><strong>Peak performance</strong></p>
<ul>
<li>Performance that's not based on running against actual code. The theoretical
highest number of instructions per second. <em>Usually good for marketing.</em></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#benchmark-standard" id="benchmark-standard">Benchmark standard</a></h2>
<p>So how are benchmark suites created? Who makes them and what are the standards?
There exist standards organizations that receive input from manufacturers, user
groups, and experts in academia and these organizations produce standard
benchmark suites. Some well known standard benchmark suites are:</p>
<ul>
<li><strong>TPC</strong> - Benchmarks used for databases, web servers, data mining, and other
transaction processing. <a href="lesson2/metrics-and-evaluation.html#references">[1]</a></li>
<li><strong>EEMBC</strong> - Used for embedded processing. <a href="lesson2/metrics-and-evaluation.html#preferences">[2]</a></li>
<li><strong>SPEC</strong> - Used to evaluate engineering work stations and raw processors. SPEC
encompasses a large set of workloads, trying to cover a variety of uses for
processors in high performance systems. A breakdown of these workloads is in the
image below. <a href="lesson2/metrics-and-evaluation.html#preferences">[3]</a></li>
</ul>
<p><img src="lesson2/./img/benchmark-standard.png" alt="benchmark-standard" /></p>
<h2><a class="header" href="#summarizing-performance" id="summarizing-performance">Summarizing performance</a></h2>
<p>To summarize performance, we are looking for the <strong>average execution time</strong>.
A demonstration on how to calculate this is shown below. We should refrain from
averaging the speedups for each application tested - averaging ratios will not
provide useable data to summarize performance. In order to acquire the average
speedup, we need to use the <strong>geometric mean</strong> for the execution times of each
computer.</p>
<p><img src="lesson2/./img/summarizing-performance.png" alt="summarizing-performance" /></p>
<h2><a class="header" href="#iron-law-of-performance" id="iron-law-of-performance">Iron Law of performance</a></h2>
<p>Processor time (CPU time) can be expressed as:
<code>(instructions/program) * (cycles/instruction) * (seconds/cycles)</code></p>
<p>So why do we think about these components of processor time instead of just
measuring processor time directly? These three components allow us to think
about the different aspects of computer architecture.</p>
<ul>
<li><code>(instructions/program)</code> - influenced by the algorithm used to create the
program, the compiler used to interpret and generate the program, and the
instruction set being used.</li>
<li><code>(cycles/instruction)</code> - influenced by the instruction set being used, and
the processor design.</li>
<li><code>(seconds/cycle)</code> - influenced by the processor design, circuit design, and
transistor physics.</li>
</ul>
<p>Computer architecture primarily focuses on instruction set and processor design,
and good designs of these two aspects attempts to balance their effects on
CPU time.</p>
<p><img src="lesson2/./img/iron-law.png" alt="iron-law" /></p>
<h2><a class="header" href="#iron-law-for-unequal-instruction-times" id="iron-law-for-unequal-instruction-times">Iron Law for unequal instruction times</a></h2>
<p>It's pretty simple to calculate CPU times when we assume that all instructions
for a program will take the same amount of cycles to execute. This isn't always
the case, however. We need to be able to sum all the cycles for each type of
instruction before we multiply this with our time per cycle. Below is a
representation of this concept, showing us how to calculate a more realistic
CPU time.</p>
<p><img src="lesson2/./img/iron-law-unequal.png" alt="iron-law-unequal" /></p>
<p>Below is an example problem in which we calculate the sum of cycles for a
program in order to determine the CPU time.</p>
<p><img src="lesson2/./img/iron-law-quiz.png" alt="iron-law-quiz" /></p>
<h2><a class="header" href="#amdahls-law" id="amdahls-law">Amdahl's Law</a></h2>
<p>This law is useful when we need to calculate the overall speedup of the entire
program, but we only enhanced a fraction of the program. Below is an image
that attempts to explain the equation for Amdahl's Law, a description of each
variable in the equation is provided:</p>
<ul>
<li><code>(1 - frac_enh)</code> - the fraction of the program that wasn't enhanced.</li>
<li><code>frac_enh</code> - the fraction of the program that was enhanced.</li>
<li><code>speedup_enh</code> - the speedup achieved due to the enhancement.</li>
</ul>
<p>It's very important to understand that <code>frac_enh</code> is a percentage of the
original execution time that is affected by the enhancement.</p>
<p><img src="lesson2/./img/amdahls-law.png" alt="amdahls-law" /></p>
<h3><a class="header" href="#implications" id="implications">Implications</a></h3>
<p>It's important to aim for enhancements that achieve a speedup on a larger
percentage of execution time for a program. This is demonstrated mathematically
below.</p>
<p><img src="lesson2/./img/amdahls-law-implications.png" alt="amdahls-law-implications" /></p>
<p>Below is an example of how to use Amdahl's Law to compare multiple possible
improvements.</p>
<p><img src="lesson2/./img/amdahls-law-quiz.png" alt="amdahls-law-quiz" /></p>
<h2><a class="header" href="#lhadmas-law" id="lhadmas-law">Lhadma's Law</a></h2>
<p>This law is jokingly used to express the opposite of Amdahl's Law. While
Amdahl's Law says to optimize for the common case, Lhadma's warns us that we
should avoid attempting to optimize too much at the expense of other parts of
our performance. An example is provided below.</p>
<p><img src="lesson2/./img/lhadmas-law.png" alt="lhadmas-law" /></p>
<h2><a class="header" href="#diminishing-returns" id="diminishing-returns">Diminishing returns</a></h2>
<p>This concept covers the idea that as computer architects, we need to
continuously review what needs to be enhanced within a system instead of
continuously enhancing the same portion of a system. This concept stems from
Amdahl's Law, as it describes that, eventually, the enhanced portion of a
system will become smaller as we apply enhancements across generations. We will
achieve a diminished speedup if we continue to enhance the same portion of the
system. We need to continually reassess what is the common case when conducting
our enhancements. Below is a high level representation of this idea.</p>
<p><img src="lesson2/./img/diminishing-returns.png" alt="diminishing-returns" /></p>
<h2><a class="header" href="#references-1" id="references-1">References</a></h2>
<ol>
<li><a href="http://www.tpc.org/tpch/">http://www.tpc.org/tpch/</a></li>
<li><a href="https://www.eembc.org/">https://www.eembc.org/</a></li>
<li><a href="https://www.spec.org/benchmarks.html">https://www.spec.org/benchmarks.html</a></li>
<li><a href="lesson2/./pdf/Lesson2Notes.pdf">Lesson 2 Notes</a></li>
</ol>
<h1><a class="header" href="#pipelining" id="pipelining">Pipelining</a></h1>
<p>This lesson reviews pipelining to set the stage for more advanced topics.</p>
<h2><a class="header" href="#pipelining-in-a-processor" id="pipelining-in-a-processor">Pipelining in a processor</a></h2>
<p>This section covers basic pipelining in a processor. Most processors are much
more complex than the example provided here, however, this is used to review
content for students.</p>
<p>In a traditional processor pipeline, we have are series of stages. The following
listing of stages is not <em>all</em> stages, but it encompasses the important ones:</p>
<ul>
<li><strong>fetch</strong></li>
<li><strong>read</strong></li>
<li><strong>decode</strong></li>
<li><strong>execute</strong></li>
<li><strong>memory access</strong></li>
<li><strong>write</strong></li>
</ul>
<p>So how does pipelining apply to these stages? Instead of fetching, decoding, and
executing one instruction at a time, while one instruction is being decoded,
another instruction can be fetched from instruction memory. Then, when one
instruction is being executed, we can be decoding the instruction behind it.
So, while the latency may not change, the throughput of instructions through
the pipeline increases. Below is a high level representation of this concept:</p>
<p><img src="lesson3/./img/pipelining-in-processor.png" alt="pipeline-in-processor" /></p>
<p>Below is an example of calculating the latency of process with and without a
pipeline.</p>
<p><img src="lesson3/./img/laundry-pipelining.png" alt="laundry-pipelining" /></p>
<p>Below is a similar example as the one above, however, this one applies to
instructions and cycles.</p>
<p><img src="lesson3/./img/instruction-pipelining.png" alt="instruction-pipelining" /></p>
<h2><a class="header" href="#pipeline-cycles-per-instruction" id="pipeline-cycles-per-instruction">Pipeline cycles per instruction</a></h2>
<p>Throughout these notes we've been assuming one cycle per instruction, or a CPI
of 1, when our pipeline is full. In the real-world, however, we'll have billions
of instructions to execute - will our CPI always be 1? Here are some reasons
why our CPI might not be 1:</p>
<ul>
<li><strong>initial fill</strong> - when the pipeline initially fills up, our CPI will not be
equal to 1. Regardless, as our instruction number reaches infinity, CPI will
begin to approach 1.</li>
<li><strong>pipeline stalls</strong> - there exists the possibility that a fault occurs in the
pipeline and an instruction stalls, causing it to have to remain at that stage
for a cycle.</li>
</ul>
<p>Below is a high-level representation of how a CPI can be greater than 1.</p>
<p><img src="lesson3/./img/pipeline-cpi.png" alt="pipeline-cpi" /></p>
<h2><a class="header" href="#references-2" id="references-2">References</a></h2>
<ol>
<li><a href="lesson3/./pdf/Lesson3Notes.pdf">Lesson 3 Notes</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
